{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"imgchroot","text":"<p>Quickly interact and customize a cloud image</p> <p> </p>"},{"location":"#overview","title":"Overview","text":"<p>imgchroot is a Go-based CLI to quickly customize cloud images in a chroot without the need to boot the image or setup a user with credentials.</p> <p>imgchroot mounts the image to a temporary directory, using the network block device (NBD) protocol. It then runs the required operation, such as a command, moving a file, or starts a shell in the chroot. Once the operation is complete the image is unmounted all without needing to boot the image itself.</p>"},{"location":"#cli","title":"CLI","text":"<p>Here are the primary functions available via the CLI:</p> <ol> <li>Chroot commands will run commands against the image inside a chroot.    This includes command execution, via a shell, or push and pull files from    the image.</li> <li>Download latest cloud images</li> </ol>"},{"location":"#chroot","title":"Chroot","text":"<p>imgchroot provides a number of different sub-commands to directly interact with a cloud image. Click to see the sub-command's CLI page for more details:</p> <ul> <li>exec: run a command on   the image</li> <li>info: information about   the image</li> <li>pull: pull a file from   the image</li> <li>push: push a file to the   image</li> <li>run: transfer and run a   file on the image</li> <li>shell: start a shell on   the image</li> </ul>"},{"location":"#download","title":"Download","text":"<p>imgchroot has the ability to find the latest cloud images as well. A user needs to provide the distro (e.g. ubuntu) and release (e.g. focal) to download. The the download will find the URL and download it.</p> <p>See the download sub-command for more information.</p>"},{"location":"#support","title":"Support","text":"<p>If you find a bug, have a question, or ideas for improvements please file an issue on GitHub.</p>"},{"location":"chroot/","title":"Chroot Commands","text":"<p>The following describes and outlines the various chroot related subcommands.</p> <p>Info</p> <p>All of these commands require root privilege to run</p>"},{"location":"chroot/#exec","title":"Exec","text":"<p>Execute a command in the chroot. Everything after the <code>--</code> is passed and executed</p> <pre><code>imgchroot exec &lt;img&gt; -- &lt;cmd&gt;\n</code></pre> <p>Here is an example:</p> <pre><code>sudo ./imgchroot exec focal-server-cloudimg-amd64.img -- cat /etc/cloud/build.info\nbuild_name: server\nserial: 20210308\n</code></pre>"},{"location":"chroot/#info","title":"Info","text":"<p>Print out information about the image and its' partitions. Optionally a user can get the information in JSON:</p> <pre><code>imgchroot info &lt;img&gt; [--json]\n</code></pre> <p>Below is an example of an Ubuntu 20.04 LTS (focal) image:</p> <pre><code>$ sudo ./imgchroot info focal-server-cloudimg-amd64.img\nfocal-server-cloudimg-amd64.img\ntype: qcow2\nsize: 529 MiB\nvirtual size: 2252 MiB\npartition table: gpt\nsector size: 512\npartitions:\n  - name: nbd0p1\n    type: Linux filesystem\n    label: cloudimg-rootfs\n    filesystem: ext4\n  - name: nbd0p14\n    type: BIOS boot\n    label:\n    filesystem:\n  - name: nbd0p15\n    type: EFI System\n    label: UEFI\n    filesystem: vfat\n</code></pre>"},{"location":"chroot/#pull","title":"Pull","text":"<p>To pull a file from the chroot use the pull subcommand:</p> <pre><code>imgchroot pull &lt;img&gt; &lt;src&gt; &lt;dst&gt;`\n</code></pre> <p>The below example demonstrates pulling the /etc/hosts file from the chroot and saves it as hosts:</p> <pre><code>$ sudo ./imgchroot pull focal-server-cloudimg-amd64.img /etc/hosts hosts\n$ cat hosts\n127.0.0.1 localhost\n\n# The following lines are desirable for IPv6 capable hosts\n::1 ip6-localhost ip6-loopback\nfe00::0 ip6-localnet\nff00::0 ip6-mcastprefix\nff02::1 ip6-allnodes\nff02::2 ip6-allrouters\nff02::3 ip6-allhosts\n</code></pre>"},{"location":"chroot/#push","title":"Push","text":"<p>To push a file to the chroot use the push subcommand:</p> <pre><code>imgchroot push &lt;img&gt; &lt;src&gt; &lt;dst&gt;\n</code></pre> <p>The following example shows how to put a file on the chroot and verify it afterwards:</p> <pre><code>$ echo \"myserver\" &gt; hostname\n$ sudo ./imgchroot push focal-server-cloudimg-amd64.img hostname /etc/hostname\n$ sudo ./imgchroot exec focal-server-cloudimg-amd64.img -- cat /etc/hostname\nmyserver\n</code></pre>"},{"location":"chroot/#run","title":"Run","text":"<p>The run command is a short-cut subcommand, which will push the file, execute it, and remove the file from the chroot:</p> <pre><code>imgchroot run &lt;img&gt; &lt;script&gt;\n</code></pre> <p>The following example runs a few commands:</p> <pre><code>$ cat myscript.sh\n#!/bin/bash\nwhoami\npwd\nls\n$ sudo ./imgchroot run focal-server-cloudimg-amd64.img myscript.sh\nroot\n/\nbin   dev  home  lib32  libx32      media  opt   root  sbin  srv  tmp  var\nboot  etc  lib   lib64  lost+found  mnt    proc  run   snap  sys  usr\n</code></pre>"},{"location":"chroot/#shell","title":"Shell","text":"<p>The shell subcommand is used to launch a shell, by default bash, on the chroot:</p> <pre><code>imgchroot shell &lt;img&gt;\n</code></pre> <p>This is a quick way to run various commands or explore the chroot:</p> <pre><code>$ sudo ./imgchroot shell focal-server-cloudimg-amd64.img\nroot:/# echo $SHELL\n/bin/bash\nroot:/# exit\nexit\n</code></pre>"},{"location":"download/","title":"Download","text":"<p>The download subcommand will download an image matching your system's architecture:</p> <pre><code>imgchroot download &lt;distro&gt; &lt;release&gt;\n</code></pre> <p>Currently the command only supports <code>ubuntu</code> as a valid distro.</p> <p>The download can resume an previous attempt if it was cancelled or connection is lost. Download will not re-download an image if it already exists.</p> <p>Below is example output:</p> <pre><code>$ imgchroot download ubuntu bionic\ndownloading https://cloud-images.ubuntu.com/bionic/current/bionic-server-cloudimg-amd64.img\n 346 of  346 MB (100.0%) @   9.2 MB/sec\nimage saved as bionic-server-cloudimg-amd64.img\n</code></pre>"},{"location":"contributing/documentation/","title":"Documentation","text":"<p>The documentation is built with MkDocs and the Material for MkDocs theme and is written in Markdown.</p>"},{"location":"contributing/documentation/#building","title":"Building","text":"<p>To build the documentation site, first setup a Python virtual environment and install the mkdocs-material package, which will pull in all other dependencies:</p> <pre><code>virtualenv .venv\n. .venv/bin/activate\npip install mkdocs-material\n</code></pre> <p>To build the docs, use the makefile target:</p> <pre><code>make docs\n</code></pre> <p>Launch a web server to pull up the docs and then point a browser at http://0.0.0.0:8000/ to view the site:</p> <pre><code>python3 -m http.server --directory site/\n</code></pre>"},{"location":"contributing/overview/","title":"Contributing","text":""},{"location":"contributing/overview/#how-to-contribute","title":"How to contribute","text":"<p>I want your help. No really, I do.</p> <p>There might be a little voice inside that tells you you're not ready; that you need to do one more tutorial, or learn another framework, or write a few more blog posts before you can help me with this project.</p> <p>I assure you, that's not the case.</p> <p>This project has some clear Contribution Guidelines and expectations that you can read below.</p> <p>The contribution guidelines outline the process that you will need to follow to get a patch merged. By making expectations and process explicit, I hope it will make it easier for you to contribute.</p> <p>And you don't just have to write code. You can help out by writing documentation, tests, or even by giving feedback about this work. (And yes, that includes giving feedback about the contribution guidelines.)</p> <p>Thank you for contributing!</p> <p>(The above is from Adrienne Lowe)</p>"},{"location":"contributing/overview/#getting-started","title":"Getting started","text":"<ul> <li>Fork the repository on GitHub</li> <li>Read the index.md for getting started and look through the   documentation for any other basic help.</li> <li>Play with the project on a variety of systems and environments, submit bugs,   and submit pull requests!</li> </ul>"},{"location":"contributing/overview/#developing-a-merge-request","title":"Developing a merge request","text":"<ul> <li>Find an issue or create your own.</li> <li>Create a feature or bug fix branch in your fork of the repo.</li> <li>Write your feature or fix your bug. Make commits of logical units.</li> <li>If needed, update the documentation in either the README or docs folder.</li> <li>Ensure the project passes the lint tests, builds, and tests pass.</li> <li>Push and submit your pull request!</li> </ul>"},{"location":"contributing/overview/#code-changes","title":"Code changes","text":"<p>The project has a basic CI setup already, which will run a lint, build, build the docs, and tests. These need to pass and I am more than willing to help you work through any issues you come across. This includes disabling or changing the config on the linters.</p> <p>These CI steps are very easy to run using the makefile via:</p> <pre><code>make lint\nmake build\nmake docs\nmake test\n</code></pre>"},{"location":"contributing/overview/#documentation-changes","title":"Documentation changes","text":"<p>If you are working on the documentation, ensure it continues to build using the steps outlined on the documentation page.</p>"},{"location":"contributing/overview/#commit-message","title":"Commit message","text":"<p>This is the rough convention I follow for commit messages:</p> <pre><code>topic: &lt;short title for what changed&gt;\n&lt;BLANK LINE&gt;\n&lt;why this change was made and what changed&gt;\n&lt;BLANK LINE&gt;\nFixes #1\n</code></pre> <p>The first line is the subject and should not be longer than 70 characters, the second line is always blank, and other lines should be wrapped at 80 characters.</p>"},{"location":"contributing/overview/#acceptance","title":"Acceptance","text":"<p>These things will make a PR more likely to be accepted:</p> <ul> <li>a well-described requirement</li> <li>tests for new code</li> <li>tests for old code!</li> <li>new code and tests follow the conventions in old code and tests</li> <li>a good commit message</li> </ul> <p>In general, I will merge a PR once I reviewed and approved it. Trivial changes (e.g., corrections to spelling) will get waved through. For substantial changes, you might get asked to resubmit the PR or divide the changes into more than one PR.</p>"},{"location":"contributing/versioning/","title":"Versioning","text":"<p>The project follows Sematic Versioning.</p>"},{"location":"contributing/versioning/#release-a-new-version","title":"Release a new version","text":"<p>The current under-development release version is kept in <code>cmd/root.go</code>:</p> <pre><code>const (\nversion = \"v1.0.0\"\n)\n</code></pre> <p>To release a new version create and push a new tag, then run the goreleaser:</p> <pre><code>git tag -a v1.2.0 -m \"Summary of release\"\ngit push origin v1.2.0\nmake release\n</code></pre> <p>This will create the corresponding GitHub Releases page and upload the artifacts to it.</p> <p>Then increment the version in <code>cmd/root.go</code> and push that change to open the next version:</p> <pre><code>git commit -am \"Open release v1.3.0\"\ngit push\n</code></pre>"}]}